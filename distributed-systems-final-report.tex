\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{cleveref} % this must be the last package to be loaded

\newcommand{\emailaddr}[1]{\href{mailto:#1}{\texttt{#1}}}

\title{\LARGE
    Nomi, Cose, Città
}
\subtitle{Final Report for the Distributed Systems Course [A.Y. 2024/25]}

\author{
    Chiara Giangiulli \\ \emailaddr{chiara.giangiulli@studio.unibo.it}
    \and
    Giovanni Pisoni\\ \emailaddr{giovanni.pisoni@studio.unibo.it}
    \and
    Dilaver Shtini\\ \emailaddr{dilaver.shtini@studio.unibo.it}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This project presents a real-time, distributed implementation of the classic Italian word game Nomi, Cose, Città.
It transforms the traditional pen-and-paper format into a modern multiplayer experience, 
where players compete in real time to find words that match given categories and starting letters.
At the end of each round, participants collaboratively validate each other’s answers through an integrated voting and chat system.
The game features a distributed architecture that combines client–server and peer-to-peer communication models, 
ensuring consistent gameplay with fault tolerance and synchronized state across all nodes.
\end{abstract}

\section{Concept}\label{concept}

\begin{itemize}
  \item The application involves creating a simple and intuitive GUI designed to help players easily interact with the system
  and compete with each other to achieve the highest score at the end of each round.

  \item Use case description
  
  The game works as follows: multiple users can join a shared game room, where they are presented with a set of categories
  and a starting letter. Players must quickly come up with words that fit the categories and begin with the given letter.
  At the end of each round, participants review and vote on one another's answers to verify their validity. Points are
  awarded based on the uniqueness and correctness of the answers, and the first player to reach a predetermined score wins the match.

  A game session can start at any time and consist of multiple rounds.
  Once the session has begun, no new players can join, as doing so would compromise score fairness. 

  In each round, players submit their answers and vote on others'
  responses in real time, under a time constraint that encourages speed and quick thinking.

  Players interact with the system through a graphical interface that provides input fields for submitting answers and offers a 
  chat feature to communicate with others during the game. Throughout the session, the system temporarily maintains data such as
  usernames and scores, which are required to manage the game state and ensure proper functionality. No persistent storage is needed
  beyond the duration of the session.
  
  The game mainly involves two roles: the players and the server. Players actively participate by submitting answers and voting,
  while the game server manages the overall game state, enforces the rules, and coordinates communication between users.
  
  \begin{figure}
    \begin{center}
        \includegraphics[width=0.75\textwidth]{figures/use_case.png}
        \caption[Use case]{Use case diagram (made with \cite{lucidchart})}
        \label{fig:use_case_diagram}
    \end{center}
  \end{figure}

\end{itemize}

\section{Requirements Elicitation and Analysis}\label{requirements}

This section details the functional and non-functional requirements for the "Nomi, Cose, Città" distributed multiplayer game.

\begin{itemize}
  \item \textbf{Functional Requirements}:
  \begin{enumerate}
    \item Players must be able to join a shared game room.
    \item The game must present players with categories and an initial letter.
    \item The players must select at max 5 categories to add to the default ones (Nomi, Cose, Città)
      from a predefined list, the server will start the game using the top 5 categories voted for, and a random letter.
      If less than 5 categories are selected, the server will fill the remaining categories with default ones.
    \item Players must be able to insert their answers before a timer runs out.
    \item At the end of each round, the system must evaluate answers (check that the first letter is the same as the given one)
    \item After the evaluation, players must be able to vote to accept or reject other players' answers.
    \item The system must provide a live chat feature for players to communicate during the game.
    \item The system must include a point system. Points are awarded for validated answers, 
      and the first player to reach a target score wins.
      The point system is as follows:
      \begin{itemize}
        \item 15 points for a valid answer in a category in which no other player has answered;
        \item 10 points for a valid answer not used by anyone else in the same category;
        \item 5 points for a valid answer but used by at least one other player in the same category;
        \item 0 points for an invalid answer.
      \end{itemize}
      The round points are the sum of each category points.
  \end{enumerate}
  \item \textbf{Non-Functional Requirements}:
    \begin{enumerate}
      \item Fault Tolerance:
        The system must ensure automatic recovery from disconnections and crashes.
        \begin{itemize}
          \item Server Recovery:
            must include persistent game state storage and automatic state restoration after crashes.
          \item Client Recovery:
            must support automatic reconnection to the server, re-establishment of P2P connections, 
            and local state caching for seamless recovery.
        \end{itemize}
      \item State Consistency:
        A synchronized game state must be maintained across all nodes.
      \item Performance:
        The system must support real-time multiplayer gameplay and chat, with low latency and high concurrency.
      \item Usability:
        The system must provide a lightweight, user-friendly interface for simple interaction.
      \item Maintainability: 
        Code must be modular and documented to make extensions and changes easy.
   \end{enumerate}
  \item \textbf{Implementation}:
    \begin{enumerate}
      \item System Architecture:  
      The system will use a hybrid architecture with a central server for the authoritative game state 
      and P2P communication between clients, chosen to ensure consistent gameplay and efficient performance.
      \item Programming Language:  
      The project will use Python (version 3.0 or higher), 
      selected for its fast development, extensive libraries, portability, and alignment with the course material.
      \item Software Tools:  
      The project will use Poetry for dependency management and packaging, 
      as it simplifies setup and ensures reliable, reproducible environments.
    \end{enumerate}
\end{itemize}

\subsection{Relevant Distributed System Features}
\label{ds-features}

\begin{itemize}
  \item Transparency
  
    The system should hide network details from players: they simply join a match and play. 
    However, full transparency is not required. 
    Users may notice some effects of failures (e.g., reconnection messages or delays).

  \item Fault tolerance and dependability
  
    Since the system is distributed, components can fail:
    \begin{itemize}
      \item if the server stops, clients must detect it and try to reconnect;
      \item if a client disconnects temporarily, it should be able to rejoin the match;
      \item the game state (answers, votes, round results) must remain consistent.
    \end{itemize}
  We aim for good availability and integrity, but the game does not require strict safety guarantees.

  \item Scalability
  
    The system must support several simultaneous users in the same room.
    However, the expected user base is small, so large-scale scalability is not necessary.
    The design remains scalable in principle but optimized for lightweight usage.

  \item Security and trust
  
    The game does not process sensitive personal data, so no advanced security mechanisms 
    are required for the scope of this project. 
    However, a minimal level of security is required:
    \begin{itemize}
      \item some form of identity (usernames) is needed;
      \item input must be validated to avoid malicious or malformed messages;
      \item voting integrity is important to avoid cheating.
    \end{itemize}

  \item Resource sharing
  
    Multiple clients interact with shared resources:
    \begin{itemize}
      \item the shared game state (letters, rounds, timers)
      \item the shared answer list
      \item the shared voting results
      \item the shared chat
    \end{itemize}
    This requires coordination and synchronization, especially to ensure that
    votes are counted consistently, rounds proceed only when all players have submitted and no two players modify the same shared state inconsistently.
    The server then acts as the synchronizing authority.
  
  \item Openness, interoperability, heterogeneity of components
  
    The system is primarily implemented in Python and does not need to integrate with external services.
    Cross-platform interoperability is relevant for testing and deployment.

  \item Evolvability and maintainability
  
    The system will evolve during development (additional rules, improvements to fault tolerance, UI updates).
    A modular architecture will help maintain and extend the project.

  \item Performance and concurrency
  
    The game is not real-time, but:
    \begin{itemize}
      \item the server must handle multiple clients concurrently;
      \item chat and votes should be delivered timely;
      \item network efficiency should avoid flooding or redundant messages.
    \end{itemize}
    High performance is not a strict requirement, but basic efficiency is important for a smooth experience.  

  \item Economy and costs
  
    The project runs on standard personal computers and has no hosting or deployment costs.
    
\end{itemize}

\section{Design}\label{design}

This chapter explains the strategies used to meet the requirements identified in the analysis. 
%
Ideally, the design should be the same, regardless of the technological choices made during the implementation phase.

\begin{quote}
You can re-arrange the sections as you prefer, but all the sections must be present in the end
\end{quote}

\noindent
\textbf{Important:} try to motivate your design choices in relation to the requirements and features identified 
in \cref{requirements} and \cref{ds-features}.

\subsection{Architecture}\label{architecture}

\begin{itemize}
  \item Which architectural style?
  %
  \begin{itemize}
    \item why?
  \end{itemize}
\end{itemize}

\subsection{Infrastructure}\label{infrastructure}

\begin{itemize}
  \item are there \emph{infrastructural components} that need to be introduced? \emph{how many}?
  %
  \begin{itemize}
    \item e.g.~\emph{clients}, \emph{servers}, \emph{load balancers},
    \emph{caches}, \emph{databases}, \emph{message brokers},
    \emph{queues}, \emph{workers}, \emph{proxies}, \emph{firewalls},
    \emph{CDNs}, \emph{etc.}
  \end{itemize}

  \item how do components \emph{distribute} over the network? \emph{where}?
  %
  \begin{itemize}
    \item e.g.~do servers / brokers / databases / etc. sit on the same
    machine? on the same network? on the same datacenter? on the same
    continent?
  \end{itemize}

  \item how do components \emph{find} each other?
  %
  \begin{itemize}
    \item how to \emph{name} components?
    \item e.g.~DNS, \emph{service discovery}, \emph{load balancing},
    \emph{etc.}
  \end{itemize}
\end{itemize}

\begin{quote}
Component diagrams are welcome here
\end{quote}

\subsection{Modelling}\label{modelling}

\begin{itemize}
  \item which \textbf{domain entities} are there?
  %
  \begin{itemize}
    \item e.g.~\emph{users}, \emph{products}, \emph{orders}, \emph{etc.}
  \end{itemize}
  
  \item how do \emph{domain entities} \textbf{map to} \emph{infrastructural components}?
  %
  \begin{itemize}
    \item e.g.~state of a video game on central server, while inputs/representations on clients
    \item e.g.~where to store messages in an IM app? for how long?
  \end{itemize}

  \item which \textbf{domain events} are there?
  %
  \begin{itemize}
    \item e.g.~\emph{user registered}, \emph{product added to cart}, \emph{order placed}, \emph{etc.}
  \end{itemize}
  
  \item which sorts of \textbf{messages} are exchanged?
  %
  \begin{itemize}
    \item e.g.~\emph{commands}, \emph{events}, \emph{queries}, \emph{etc.}
  \end{itemize}

  \item what information does the \textbf{state} of the system comprehend
  %
  \begin{itemize}
    \item e.g.~\emph{users' data}, \emph{products' data}, \emph{orders' data}, \emph{etc.}
  \end{itemize}
\end{itemize}

\begin{quote}
Class diagram are welcome here
\end{quote}

\subsection{Interaction}\label{interaction}

\begin{itemize}
  \item how do components \emph{communicate}? \emph{when}? \emph{what}?
  \item \emph{which} \textbf{interaction patterns} do they enact?
\end{itemize}

\begin{quote}
Sequence diagrams are welcome here
\end{quote}

\subsection{Behaviour}\label{behaviour}

\begin{itemize}
  \item how does \emph{each} component \textbf{behave} individually (e.g.~in \emph{response} to \emph{events} or messages)?
  \begin{itemize}
    \item some components may be \emph{stateful}, others \emph{stateless}
  \end{itemize}

  \item which components are in charge of updating the \textbf{state} of the system? \emph{when}? \emph{how}?
\end{itemize}

\begin{quote}
State diagrams are welcome here
\end{quote}

\subsection{Data and Consistency Issues}\label{data-and-consistency-issues}

\begin{itemize}
  \item Is there any data that needs to be stored?
  %
  \begin{itemize}
    \item \emph{what} data? \emph{where}? \emph{why}?
  \end{itemize}
  
  \item how should \emph{persistent data} be \textbf{stored}?
  %
  \begin{itemize}
    \item e.g.~relations, documents, key-value, graph, etc.
    \item why?
  \end{itemize}
  
  \item Which components perform queries on the database?
  %
  \begin{itemize}
    \item \emph{when}? \emph{which} queries? \emph{why}?
    \item concurrent read? concurrent write? why?
  \end{itemize}
  
  \item Is there any data that needs to be shared between components?
  %
  \begin{itemize}
    \item \emph{why}? \emph{what} data?
  \end{itemize}
\end{itemize}

\subsection{Fault-Tolerance}\label{fault-tolerance}

\begin{itemize}
  \item Is there any form of data \textbf{replication} / federation / sharing?
  %
  \begin{itemize}
    \item \emph{why}? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any \textbf{heart-beating}, \textbf{timeout}, \textbf{retry mechanism}?
  %
  \begin{itemize}
    \item \emph{why}? \emph{among} which components? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any form of \textbf{error handling}?
  %
  \begin{itemize}
    \item \emph{what} happens when a component fails? \emph{why}? \emph{how}?
  \end{itemize}
\end{itemize}

\subsection{Availability}\label{availability}

\begin{itemize}
  \item Is there any \textbf{caching} mechanism?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}
  
  \item Is there any form of \textbf{load balancing}?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item In case of \textbf{network partitioning}, how does the system behave?
  %
  \begin{itemize}
    \item \emph{why}? \emph{how}?
  \end{itemize}
\end{itemize}

\subsection{Security}\label{security}

\begin{itemize}
  \item Is there any form of \textbf{authentication}?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item Is there any form of \textbf{authorization}?
  %
  \begin{itemize}
    \item which sort of \emph{access control}?
    \item which sorts of users / \emph{roles}? which \emph{access rights}?
  \end{itemize}

  \item Are \textbf{cryptographic schemas} being used?
  %
  \begin{itemize}
    \item e.g.~token verification,
    \item e.g.~data encryption, etc.
  \end{itemize}
\end{itemize}

\section{Implementation}\label{implementation}

Please report here all the implementation (technology-dependent) choices you made while implementing your design.

\begin{quote}
  If you run out of time for this project, you may consider leaving some aspect unimplemented, 
  and simply discuss how you would have implemented them.
  %
  In this case, better would be to discuss unimplemented features in \cref{future-works}.
\end{quote}

\begin{itemize}
  \item which \textbf{network protocols} to use?
  %
  \begin{itemize}
    \item e.g.~UDP, TCP, HTTP, WebSockets, gRPC, XMPP, AMQP, MQTT, etc.
  \end{itemize}
  
  \item how should \emph{in-transit data} be \textbf{represented}?
  %
  \begin{itemize}
    \item e.g.~JSON, XML, YAML, Protocol Buffers, etc.
  \end{itemize}
  
  \item how should \emph{databases} be \textbf{queried}?
  %
  \begin{itemize}
    \item e.g.~SQL, NoSQL, etc.
  \end{itemize}
  
  \item how should components be \emph{authenticated}?
  %
  \begin{itemize}
    \item e.g.~OAuth, JWT, etc.
  \end{itemize}

  \item how should components be \emph{authorized}?
  %
  \begin{itemize}
    \item e.g.~RBAC, ABAC, etc.
  \end{itemize}
\end{itemize}

\subsection{Technological details}\label{technological-details}

\begin{itemize}
  \item any particular \emph{framework} / \emph{technology} being exploited goes here
\end{itemize}

\section{Validation}\label{validation}

\subsection{Automatic Testing}\label{automatic-testing}

\begin{itemize}
  \item how were individual components \textbf{\emph{unit}-test}ed?
  
  \item how was communication, interaction, and/or integration among components tested?
  
  \item how to \textbf{\emph{end-to-end}-test} the system?
  %
  \begin{itemize}
    \item e.g.~production vs.~test environment
  \end{itemize}

  \item for each test specify:
  %
  \begin{itemize}
    \item rationale of individual tests
    \item how were the test automated
    \item how to run them
    \item which requirement they are testing, if any
  \end{itemize}
\end{itemize}

\begin{quote}
recall that \emph{deployment} \textbf{automation} is commonly used to \emph{test} the system in \emph{production-like} environment
\end{quote}

\begin{quote}
recall to test corner cases (crashes, errors, etc.)
\end{quote}

\subsection{Acceptance test}\label{acceptance-test}

\begin{itemize}
  \item did you perform any \emph{manual} testing?
  %
  \begin{itemize}
    \item what did you test?
    \item why wasn't it automatic?
  \end{itemize}
\end{itemize}

\section{Deployment}\label{deployment}

\begin{itemize}
  \item should one install your software from scratch, how to do it?
  %
  \begin{itemize}
    \item provide instructions
    \item provide expected outcomes
  \end{itemize}

  \item what software should be installed on the machines to run your project? which versions?
  
  \item should one set environment variables or configuration files?
  
  \item if you're using containerization (e.g.~Docker), 
  describe how you engineered your deployment scrips (e.g. \texttt{docker-compose.yml} files)
\end{itemize}

\section{User Guide}\label{user-guide}

\begin{itemize}
  \item how to use your software?
  %
  \begin{itemize}
    \item provide instructions
    \item provide expected outcomes
    \item provide screenshots if possible
  \end{itemize}
\end{itemize}

\section{Self-evaluation}\label{self-evaluation}

\begin{itemize}
  \item An individual section is required for each member of the group
  \item Each member must self-evaluate their work, listing the strengths and weaknesses of the product
  \item Each member must describe their role within the group as objectively as possible.
\end{itemize}

It should be noted that each student is only responsible for their own section.

\section{Future works}\label{future-works}

Discuss possible future works, improvements, extensions, optimizations, etc.

Also discuss here any unimplemented feature, and how you would have implemented it.

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
