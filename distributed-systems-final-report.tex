\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{float}
\usepackage{cleveref} % this must be the last package to be loaded

\newcommand{\emailaddr}[1]{\href{mailto:#1}{\texttt{#1}}}

\title{\LARGE
    Nomi, Cose, Città
}
\subtitle{Final Report for the Distributed Systems Course [A.Y. 2024/25]}

\author{
    Chiara Giangiulli \\ \emailaddr{chiara.giangiulli@studio.unibo.it}
    \and
    Giovanni Pisoni\\ \emailaddr{giovanni.pisoni@studio.unibo.it}
    \and
    Dilaver Shtini\\ \emailaddr{dilaver.shtini@studio.unibo.it}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This project presents a real-time, distributed implementation of the classic Italian word game Nomi, Cose, Città.
It transforms the traditional pen-and-paper format into a modern multiplayer experience, 
where players compete in real time to find words that match given categories and starting letters.
At the end of each round, participants collaboratively validate each other’s answers through an integrated voting and chat system.
The game features a distributed architecture that combines client–server and peer-to-peer communication models, 
ensuring consistent gameplay with fault tolerance and synchronized state across all nodes.
\end{abstract}

\section{Concept}\label{concept}

\begin{itemize}
  \item The application involves creating a simple and intuitive GUI designed to help players easily interact with the system
  and compete with each other to achieve the highest score at the end of each round.

  \item Use case description
  
  The game works as follows: multiple users can join a shared game room, where they are presented with a set of categories
  and a starting letter. Players must quickly come up with words that fit the categories and begin with the given letter.
  At the end of each round, participants review and vote on one another's answers to verify their validity. Points are
  awarded based on the uniqueness and correctness of the answers, and the first player to reach a predetermined score wins the match.

  A game session can start at any time and consist of multiple rounds.
  Once the session has begun, no new players can join, as doing so would compromise score fairness. 

  In each round, players submit their answers and vote on others'
  responses in real time, under a time constraint that encourages speed and quick thinking.

  Players interact with the system through a graphical interface that provides input fields for submitting answers and offers a 
  chat feature to communicate with others during the game. Throughout the session, the system temporarily maintains data such as
  usernames and scores, which are required to manage the game state and ensure proper functionality. No persistent storage is needed
  beyond the duration of the session.
  
  The game mainly involves two roles: the players and the server. Players actively participate by submitting answers and voting,
  while the game server manages the overall game state, enforces the rules, and coordinates communication between users.
  
  \begin{figure}
    \begin{center}
        \includegraphics[width=0.75\textwidth]{figures/use_case.png}
        \caption[Use case]{Use case diagram (made with \cite{lucidchart})}
        \label{fig:use_case_diagram}
    \end{center}
  \end{figure}

\end{itemize}

\section{Requirements Elicitation and Analysis}\label{requirements}

This section details the functional and non-functional requirements for the "Nomi, Cose, Città" distributed multiplayer game.

\begin{itemize}
  \item \textbf{Functional Requirements}:
  \begin{enumerate}
    \item Players must be able to join a shared game room.
    \item The game must present players with categories and an initial letter.
    \item The players must select at max 5 categories to add to the default ones (Nomi, Cose, Città)
      from a predefined list, the server will start the game using the top 5 categories voted for, and a random letter.
      If less than 5 categories are selected, the server will fill the remaining categories with default ones.
    \item Players must be able to insert their answers before a timer runs out.
    \item At the end of each round, the system must evaluate answers (check that the first letter is the same as the given one)
    \item After the evaluation, players must be able to vote to accept or reject other players' answers.
    \item The system must provide a live chat feature for players to communicate during the game.
    \item The system must include a point system. Points are awarded for validated answers, 
      and the first player to reach a target score wins.
      The point system is as follows:
      \begin{itemize}
        \item 15 points for a valid answer in a category in which no other player has answered;
        \item 10 points for a valid answer not used by anyone else in the same category;
        \item 5 points for a valid answer but used by at least one other player in the same category;
        \item 0 points for an invalid answer.
      \end{itemize}
      The round points are the sum of each category points.
  \end{enumerate}
  \item \textbf{Non-Functional Requirements}:
    \begin{enumerate}
      \item Fault Tolerance:
        The system must ensure automatic recovery from disconnections and crashes.
        \begin{itemize}
          \item Server Recovery:
            must preserve and restore the in-session game state in case of temporary failures.
          \item Client Recovery:
            must support automatic reconnection to the server, re-establishment of P2P connections, 
            and local state caching for seamless recovery.
        \end{itemize}
      \item State Consistency:
        A synchronized game state must be maintained across all nodes.
      \item Performance:
        The system must support real-time multiplayer gameplay and chat, with low latency and high concurrency.
      \item Usability:
        The system must provide a lightweight, user-friendly interface for simple interaction.
      \item Maintainability: 
        Code must be modular and documented to make extensions and changes easy.
   \end{enumerate}
  \item \textbf{Implementation}:
    \begin{enumerate}
      \item System Architecture:  
      The system will use a hybrid architecture with a central server for the authoritative game state 
      and P2P communication between clients, chosen to ensure consistent gameplay and efficient performance.
      \item Programming Language:  
      The project will use Python (version 3.0 or higher), 
      selected for its fast development, extensive libraries, portability, and alignment with the course material.
      \item Software Tools:  
      The project will use Poetry for dependency management and packaging, 
      as it simplifies setup and ensures reliable, reproducible environments.
    \end{enumerate}
\end{itemize}

\subsection{Relevant Distributed System Features}
\label{ds-features}

\begin{itemize}
  \item Transparency
  
    The system should hide network details from players: they simply join a match and play. 
    However, full transparency is not required. 
    Users may notice some effects of failures (e.g., reconnection messages or delays).

  \item Fault tolerance and dependability
  
    Since the system is distributed, components can fail:
    \begin{itemize}
      \item if the server stops, clients must detect it and try to reconnect;
      \item if a client disconnects temporarily, it should be able to rejoin the match;
      \item the game state (answers, votes, round results) must remain consistent.
    \end{itemize}
  We aim for good availability and integrity, but the game does not require strict safety guarantees.

  \item Scalability
  
    The system must support several simultaneous users in the same room.
    However, the expected user base is small, so large-scale scalability is not necessary.
    The design remains scalable in principle but optimized for lightweight usage.

  \item Security and trust
  
    The game does not process sensitive personal data, so no advanced security mechanisms 
    are required for the scope of this project. 
    However, a minimal level of security is required:
    \begin{itemize}
      \item some form of identity (usernames) is needed;
      \item input must be validated to avoid malicious or malformed messages;
      \item voting integrity is important to avoid cheating.
    \end{itemize}

  \item Resource sharing
  
    Multiple clients interact with shared resources:
    \begin{itemize}
      \item the shared game state (letters, rounds, timers)
      \item the shared answer list
      \item the shared voting results
      \item the shared chat
    \end{itemize}
    This requires coordination and synchronization, especially to ensure that
    votes are counted consistently, rounds proceed only when all players have submitted and no two players modify the same shared state inconsistently.
    The server then acts as the synchronizing authority.
  
  \item Openness, interoperability, heterogeneity of components
  
    The system is primarily implemented in Python and does not need to integrate with external services.
    Cross-platform interoperability is relevant for testing and deployment.

  \item Evolvability and maintainability
  
    The system will evolve during development (additional rules, improvements to fault tolerance, UI updates).
    A modular architecture will help maintain and extend the project.

  \item Performance and concurrency
  
    The game is not real-time, but:
    \begin{itemize}
      \item the server must handle multiple clients concurrently;
      \item chat and votes should be delivered timely;
      \item network efficiency should avoid flooding or redundant messages.
    \end{itemize}
    High performance is not a strict requirement, but basic efficiency is important for a smooth experience.  

  \item Economy and costs
  
    The project runs on standard personal computers and has no hosting or deployment costs.
    
\end{itemize}

\section{Design}\label{design}

This chapter explains the design strategies used to meet the requirements identified in the analysis phase,
particularly emphasizing fault tolerance, state consistency, and real-time interaction. 

\subsection{Architecture}\label{architecture}

The system adopts a \textbf{hybrid architecture} combining client-server and peer-to-peer (P2P) communication models.

\begin{itemize}
  \item \textbf{Client-Server:} 
  The server acts as the central authority. 
  It manages the game session, enforces the timer, and performs the initial check on answers 
  (verifying the starting letter). 
  Finally, it collects the results to update the global score.

  \item \textbf{Peer-to-Peer:} 
  Clients communicate directly during the voting phase to validate the content of the answers and to exchange chat messages. 
  This allows players to reach a consensus without passing every message through the server.
\end{itemize}

This division of labor improves efficiency. 
The server is treated as a statekeeper and does not need to process high-frequency traffic like chat or voting debates. Instead, it only receives the final outcome of the round.
Additionally, this approach increases resilience: since voting happens between peers, the interaction remains smooth even if the connection to the central server experiences temporary latency.

\subsubsection*{Alternative Architectures Considered}

\begin{itemize}
  \item Pure Client-Server:
  A pure client-server architecture was evaluated, where all communication flows through the central server. 
  This was rejected to avoid a total dependency on the central node. 
  In a pure C/S model, a temporary server failure would interrupt all interactions, including chat.
  The hybrid approach allows social interaction to persist during server glitches.
  \item Pure Peer-to-Peer (P2P):
  A pure P2P architecture with distributed consensus was also considered. 
  However, this was rejected due to the complexity of maintaining a consistent global state 
  (e.g., scores and timers) without a central authority. 
  A fully decentralized model would make it significantly harder to synchronize rounds and prevent cheating.
\end{itemize}

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=0.75\textwidth]{figures/architecture.png}
      \caption[Architecture]{Architecture diagram (made with \cite{lucidchart})}
      \label{fig:arch_diagram}
  \end{center}
\end{figure}

\subsection{Infrastructure}\label{infrastructure}

Given the project scope and the hybrid architecture, the infrastructure is designed to be lightweight.

\subsubsection*{Infrastructural Components}
The system relies on a minimal set of components to reduce deployment complexity:

\begin{itemize}
    \item \textbf{Central Server Node (1 instance):} 
    A single Python process hosting the game logic and session management. 
    Instead of a heavy external database, it uses in-memory storage for real-time game state, 
    backed by a local file-based persistence mechanism to handle crash recovery.
    
    \item \textbf{Client Nodes ($N$ instances):} 
    The players' machines running the client application. 
    Each client acts as a peer in the network, capable of acting as both a sender and receiver for chat and voting messages.
\end{itemize}

\subsubsection*{Network Distribution}
The components are distributed over a logical LAN.
\begin{itemize}
    \item The Server and Clients communicate via standard TCP/IP sockets.
    \item To bypass complex NAT traversal and firewall configuration issues, typical of P2P systems over the public Internet, 
    the system assumes that all nodes are reachable within the same network segment or connected via a VPN.
\end{itemize}

\subsubsection*{Service Discovery}
Since there is no static registry for the dynamic client IPs, the system implements a centralized discovery mechanism:

\begin{itemize}
    \item \textbf{Server Discovery:} Clients identify the server via a known endpoint provided at startup configuration.
    \item \textbf{Peer Discovery:} The Central Server acts as a dynamic registry. 
    Upon joining the lobby, each client registers its listening socket (IP:Port) with the server. 
    When the round starts, the server broadcasts the \textit{peer map} (a list mapping usernames to their respective addresses) to all participants, 
    enabling them to establish direct P2P connections.
\end{itemize}

\subsection{Modelling}\label{modelling}

The system domain is modeled around the concept of a synchronized game session 
where state ownership is distributed according to the hybrid architecture.

\subsubsection*{Domain Entities and Infrastructure Mapping}

\begin{itemize}
    \item \textbf{Game Session:} 
    The core entity representing the match.
    It resides in the Server's memory and contains the list of connected Users,
    the configuration (target score, chosen categories), and the global status.
    
    \item \textbf{Round:} 
    Represents the current turn.
    \begin{itemize}
        \item \textit{Server:} stores the authoritative data: the chosen letter, the start/end timestamps, and the collection of submitted answers.
        \item \textit{Client:} maintains a local replica of the round data to drive the UI.
    \end{itemize}

    \item \textbf{Vote:} 
    Represents a judgment (valid/invalid) cast by Peer A on Peer B's answer. 
    These are exchanged P2P. 
    The Server only receives the aggregated outcome to compute the score.

    \item \textbf{Chat Message:}
    Entities existing only in the clients' volatile memory and UI buffers. 
    The server does not store chat history.

\end{itemize}

\subsubsection*{System State}
The state of the system is divided into:
\begin{itemize}
    \item \textbf{Global Authoritative State (Server):} 
    Includes the registry of active players $(ID, IP, Port)$, current scores
    and the canonical state of the game flow. 
    This state is periodically checkpointed to a local file for crash recovery.
    
    \item \textbf{Local View State (Client):} 
    Includes the player's own inputs, the cached answers of other players (received for voting), and the chat log. 
    This state is reconstructed from the Server upon reconnection.
\end{itemize}

\subsubsection*{Domain Events and Messages}
Communication relies on serialized JSON messages, categorized by interaction type:

\begin{enumerate}
    \item \textbf{Commands (Client $\rightarrow$ Server):} 
    Messages requesting a state change.
    \begin{itemize}
        \item \texttt{CMD\_JOIN}: Request to enter the room.
        \item \texttt{CMD\_SUBMIT}: Sending the filled word list for the round.
    \end{itemize}

    \item \textbf{State Updates (Server $\rightarrow$ Client):} 
    Events broadcasting authoritative changes.
    \begin{itemize}
        \item \texttt{EVT\_ROUND\_START}: Contains the letter and categories.
        \item \texttt{EVT\_PEER\_MAP}: Updates the client with the list of other peers for P2P connection.
        \item \texttt{EVT\_SCORE\_UPDATE}: Broadcasts the new leaderboard after a round.
    \end{itemize}

    \item \textbf{Peer Interactions (P2P Client $\leftrightarrow$ Client):} 
    Direct messages for social and validation logic.
    \begin{itemize}
        \item \texttt{MSG\_CHAT}: A text message for the room.
        \item \texttt{MSG\_VOTE}: A payload containing \{target\_user, category, approval\_boolean\}.
    \end{itemize}
\end{enumerate}

\begin{figure}
  \begin{center}
      \includegraphics[width=0.9\textwidth]{figures/class_diagram.png}
      \caption[Class diagram]{Class diagram (made with \cite{lucidchart})}
      \label{fig:class_diagram}
  \end{center}
\end{figure}

  \subsection{Interaction}\label{interaction}

\begin{itemize}
  \item how do components \emph{communicate}? \emph{when}? \emph{what}?
  \item \emph{which} \textbf{interaction patterns} do they enact?
\end{itemize}

\begin{quote}
Sequence diagrams are welcome here
\end{quote}

\subsection{Behaviour}\label{behaviour}

\begin{itemize}
  \item how does \emph{each} component \textbf{behave} individually (e.g.~in \emph{response} to \emph{events} or messages)?
  \begin{itemize}
    \item some components may be \emph{stateful}, others \emph{stateless}
  \end{itemize}

  \item which components are in charge of updating the \textbf{state} of the system? \emph{when}? \emph{how}?
\end{itemize}

\begin{quote}
State diagrams are welcome here
\end{quote}

\subsection{Data and Consistency Issues}\label{data-and-consistency-issues}

\begin{itemize}
  \item Is there any data that needs to be stored?
  %
  \begin{itemize}
    \item \emph{what} data? \emph{where}? \emph{why}?
  \end{itemize}
  
  \item how should \emph{persistent data} be \textbf{stored}?
  %
  \begin{itemize}
    \item e.g.~relations, documents, key-value, graph, etc.
    \item why?
  \end{itemize}
  
  \item Which components perform queries on the database?
  %
  \begin{itemize}
    \item \emph{when}? \emph{which} queries? \emph{why}?
    \item concurrent read? concurrent write? why?
  \end{itemize}
  
  \item Is there any data that needs to be shared between components?
  %
  \begin{itemize}
    \item \emph{why}? \emph{what} data?
  \end{itemize}
\end{itemize}

\subsection{Fault-Tolerance}\label{fault-tolerance}

\begin{itemize}
  \item Is there any form of data \textbf{replication} / federation / sharing?
  %
  \begin{itemize}
    \item \emph{why}? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any \textbf{heart-beating}, \textbf{timeout}, \textbf{retry mechanism}?
  %
  \begin{itemize}
    \item \emph{why}? \emph{among} which components? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any form of \textbf{error handling}?
  %
  \begin{itemize}
    \item \emph{what} happens when a component fails? \emph{why}? \emph{how}?
  \end{itemize}
\end{itemize}

\subsection{Availability}\label{availability}

\begin{itemize}
  \item Is there any \textbf{caching} mechanism?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}
  
  \item Is there any form of \textbf{load balancing}?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item In case of \textbf{network partitioning}, how does the system behave?
  %
  \begin{itemize}
    \item \emph{why}? \emph{how}?
  \end{itemize}
\end{itemize}

\subsection{Security}\label{security}

\begin{itemize}
  \item Is there any form of \textbf{authentication}?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item Is there any form of \textbf{authorization}?
  %
  \begin{itemize}
    \item which sort of \emph{access control}?
    \item which sorts of users / \emph{roles}? which \emph{access rights}?
  \end{itemize}

  \item Are \textbf{cryptographic schemas} being used?
  %
  \begin{itemize}
    \item e.g.~token verification,
    \item e.g.~data encryption, etc.
  \end{itemize}
\end{itemize}

\section{Implementation}\label{implementation}

Please report here all the implementation (technology-dependent) choices you made while implementing your design.

\begin{quote}
  If you run out of time for this project, you may consider leaving some aspect unimplemented, 
  and simply discuss how you would have implemented them.
  %
  In this case, better would be to discuss unimplemented features in \cref{future-works}.
\end{quote}

\begin{itemize}
  \item which \textbf{network protocols} to use?
  %
  \begin{itemize}
    \item e.g.~UDP, TCP, HTTP, WebSockets, gRPC, XMPP, AMQP, MQTT, etc.
  \end{itemize}
  
  \item how should \emph{in-transit data} be \textbf{represented}?
  %
  \begin{itemize}
    \item e.g.~JSON, XML, YAML, Protocol Buffers, etc.
  \end{itemize}
  
  \item how should \emph{databases} be \textbf{queried}?
  %
  \begin{itemize}
    \item e.g.~SQL, NoSQL, etc.
  \end{itemize}
  
  \item how should components be \emph{authenticated}?
  %
  \begin{itemize}
    \item e.g.~OAuth, JWT, etc.
  \end{itemize}

  \item how should components be \emph{authorized}?
  %
  \begin{itemize}
    \item e.g.~RBAC, ABAC, etc.
  \end{itemize}
\end{itemize}

\subsection{Technological details}\label{technological-details}

\begin{itemize}
  \item any particular \emph{framework} / \emph{technology} being exploited goes here
\end{itemize}

\section{Validation}\label{validation}

\subsection{Automatic Testing}\label{automatic-testing}

\begin{itemize}
  \item how were individual components \textbf{\emph{unit}-test}ed?
  
  \item how was communication, interaction, and/or integration among components tested?
  
  \item how to \textbf{\emph{end-to-end}-test} the system?
  %
  \begin{itemize}
    \item e.g.~production vs.~test environment
  \end{itemize}

  \item for each test specify:
  %
  \begin{itemize}
    \item rationale of individual tests
    \item how were the test automated
    \item how to run them
    \item which requirement they are testing, if any
  \end{itemize}
\end{itemize}

\begin{quote}
recall that \emph{deployment} \textbf{automation} is commonly used to \emph{test} the system in \emph{production-like} environment
\end{quote}

\begin{quote}
recall to test corner cases (crashes, errors, etc.)
\end{quote}

\subsection{Acceptance test}\label{acceptance-test}

\begin{itemize}
  \item did you perform any \emph{manual} testing?
  %
  \begin{itemize}
    \item what did you test?
    \item why wasn't it automatic?
  \end{itemize}
\end{itemize}

\section{Deployment}\label{deployment}

\begin{itemize}
  \item should one install your software from scratch, how to do it?
  %
  \begin{itemize}
    \item provide instructions
    \item provide expected outcomes
  \end{itemize}

  \item what software should be installed on the machines to run your project? which versions?
  
  \item should one set environment variables or configuration files?
  
  \item if you're using containerization (e.g.~Docker), 
  describe how you engineered your deployment scrips (e.g. \texttt{docker-compose.yml} files)
\end{itemize}

\section{User Guide}\label{user-guide}

\begin{itemize}
  \item how to use your software?
  %
  \begin{itemize}
    \item provide instructions
    \item provide expected outcomes
    \item provide screenshots if possible
  \end{itemize}
\end{itemize}

\section{Self-evaluation}\label{self-evaluation}

\begin{itemize}
  \item An individual section is required for each member of the group
  \item Each member must self-evaluate their work, listing the strengths and weaknesses of the product
  \item Each member must describe their role within the group as objectively as possible.
\end{itemize}

It should be noted that each student is only responsible for their own section.

\section{Future works}\label{future-works}

Discuss possible future works, improvements, extensions, optimizations, etc.

Also discuss here any unimplemented feature, and how you would have implemented it.

\newpage
\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
